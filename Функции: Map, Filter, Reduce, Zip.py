# Функция map берет нашу функцую которую приняла в качестве параметра и применяет ее к каждому
# элементу в той последовательности которые мы также передали в параметре нашей функции map

with open('milcford.txt') as m:
    n = int(m.readline()) # Метод readline читает файл построчно
    for i in range(n):
        a, b = map(int, m.readline().split())
        print(a, b)

def f(a,b):
    return a * b

a = map(f, [1, 3, 4,], [3, 6, 9]) # Передаем функции map собственную функцию которая перемножает
# первый элемент на второй, мы передали два списка первый элемент умножается на первый элемент из второго списка и т.д.
print(list(a)) # Преобразовываем объект map в список

b = map(lambda x: x + 15, (1, 3, 5)) # Функции map передали лямбду в одну строку
print(list(b))

def A(a): # Функция возвращает четное число
    if a % 2 == 0:
        return a

s = filter(A, (2, 4, 5)) # Функции filter передаем, нашу функцию A, а после запятой указаны аргументы к которым применяется фильтр
print(list(s))

d = filter(lambda x: x % 2 == 0, (2, 4, 5)) # Все тоже самое, только с применением лямбда
print(list(d))

from functools import reduce
print(reduce(lambda a, b: a * b, (50, 57, 89, 12, 100))) # Сперва 50 * 57 = 2850 * 89 = 253650 * 12 = 3043800 * 100 = 304380000

e = [1, 2, 3, 4, 5, 6]
g = 'abcdefg'
j = (5,3,2,6,7,6)
result = zip(e, g, j) # Метод zip объеденяет между собой списки, 1е значение 1го списка с 1м значение 2го списка и т.д.
print(list(result))